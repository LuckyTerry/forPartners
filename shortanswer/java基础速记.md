# java基础速记

1. 面向对象和面向过程 
- 面向过程性能比面向对象高，但是没有面向对象易维护、易复用、易扩展
- 面向对象性能比面向过程低，但是它有封装、继承、多态的特性，所以易维护、易复用、易扩展。

2. jvm jdk jre 编译与解释共存
- JVM 是 Java Visual Machine，它是运行 Java 字节码的虚拟机
- JDK 是 Java Development Kit，它是功能齐全的 Java SDK
- JRE 是 Java Runtime Environment，它是运行时环境
- 有JIT(just in time)编译器能预先将热点代码编译成机器码，也有AOT(ahead of time)编译器能预先将代码编译成机器码

3. 字符型常量和字符串常量
- 形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符
- 含义上: 字符常量相当于一个ASCII码; 字符串常量代表一个地址值(表示该字符串在内存中存放位置)
- 内存上: 字符常量只占 2 个字节; 字符串常量占若干个字节 

4. 构造器是否可以被override
- 构造器 不能被 override（重写）,但是可以 overload（重载）

5. 重载和重写
- 重载 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同
- 重写 是子类对父类可访问方法重新编写，方法名、参数必须相同，返回值范围、抛出异常范围小于等于父类，访问修饰符范围大于等于父类

6. 封装继承多态
- 封装 把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，体现一个最少知道原则
- 继承 子类继承父类，通过继承我们能够非常方便地复用以前的代码
- 多态 变量所指向的具体类型在编程时并不确定，而是在程序运行期间才确定，体现一个里氏替换原则

7. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?
- 可变性 String类用final修复char数组，所以不可变；而SB和SB没有final修饰，所以是可变的
- 线程安全 StringBuffer线程安全，StringBuilder不安全
- 性能 少量数据用String，大量数据，单线程用StringBuilder，多线程用StringBuffer

8. 自动装箱与拆箱
- 装箱：将基本类型用它们对应的引用类型包装起来，需要注意常量池缓存
- 拆箱：将包装类型转换为基本数据类型，需要注意隐式拆箱

9. 在 Java 中定义一个不做事且没有参数的构造方法的作用
- 执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”

10. import java 和 javax 有什么区别？
- javax 当时只是扩展 API 包来使用，然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分

11. 接口和抽象类的区别是什么？
- 一个类可以实现多个接口，但只能实现一个抽象类
- 接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定
- 接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符
- 抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为规范

12. 成员变量与局部变量的区别有哪些？
- 从语法来看: 成员变量是属于类的，而局部变量属于函数
- 从内存来看: 成员变量位于堆内存，而局部变量位于栈内存
- 从初值来看: 成员变量如果没有被赋初值，则会自动赋默认值，而局部变量则不会自动赋值

13.  静态方法和实例方法有何不同
- 调用形式上：调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式
- 访问范围上：静态方法只能访问类的静态成员变量和静态方法，而不能访问实例成员变量和实例方法；实例方法则无此限制

14. == 与 equals
- == : 它的作用是判断两个对象的地址是不是相等
- equals() : 它的作用是判断两个对象是否相等
    - 类没有覆盖 equals() 方法，等价于“==”
    - 类覆盖了 equals() 方法，比较两个对象的内容是否相等

15. 你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？
- equals 为true，则 hashcode 一定也是相同的
- 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖

16. 为什么 Java 中只有值传递？
- 我们来模拟一下
- 方法参数是基本类型：在方法内部执行swap逻辑，操作不影响调用方的值
- 方法参数是引用类型：在方法内部执行swap逻辑，同样不影响调用方的值
- 所以说不存在引用传递，Java中的引用其实只对应C++的指针，C++的引用是另一个概念

17. final 关键字用在哪3个地方，代表什么
- 变量：不可变。基本类型值不能更改，引用类型不能指向别的对象
- 方法：不可被重写
- 类：不可被继承，方法默认不可被重写

18. Java 序列化中如果有些字段不想进行序列化，怎么办？
- 使用 transient 关键字修饰

19. Java 中 IO 流分为几种?
- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；
- 按照流的角色划分，可以分为节点流和处理流。

20. 既然有了字节流,为什么还要有字符流?
- 字符到字节的转换耗时，而且编码容易出错，所以I/O流就提供了一个直接操作字符的接口，方便我们使用

21. BIO,NIO,AIO 有什么区别?
- BIO (Blocking I/O): 同步阻塞 I/O 模式，面向流的 I/O 操作方法
- NIO (New I/O): 同步非阻塞的 I/O 模型，面向缓冲，基于通道的 I/O 操作方法
- AIO (Asynchronous I/O): 异步IO，基于事件和回调机制实现

22. 深拷贝 vs 浅拷贝
- 浅拷贝：对基本数据类型进行值拷贝，对引用数据类型进行引用地址拷贝
- 深拷贝：对基本数据类型进行值拷贝，对引用数据类型，创建一个新的对象，并复制其内容

23. Collections 工具类和 Arrays 工具类常见方法
- Collections.syncMap
- Arrays.asList

24. static 关键字主要有以下四种使用场景
- 成员变量和成员方法：被修饰的成员属于类
- 静态代码块：不管创建多少对象，静态代码块只执行一次，(静态代码块—>非静态代码块—>构造方法)
- 静态内部类：不会隐式持有外部对象的引用

25. this 关键字 super 关键字
- this关键字用于引用类的当前实例
- super关键字用于从子类访问父类的变量和方法
- 在构造函数中使用时，this和super都要放在首行

26. 反射机制介绍
- 在运行中，动态获取对象信息以及动态调用对象方法的功能

27. 反射机制优缺点
- 优点： 运行时类型的判断，动态加载类，提高代码灵活度
- 缺点： 1,性能瓶颈：反射相当于一系列解释操作，性能比直接的 java 代码要慢一些。2,安全问题，可以动态改变类的属性，也就意味着有安全风险

28. 反射的应用场景
- 框架设计的灵魂
    - Spring 的 IOC 和 AOP 功能
    - JDBC 通过 Class.forName() 加载数据库驱动