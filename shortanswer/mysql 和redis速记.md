# mysql 和redis速记
1. 介绍一下mysql
2. 关系型数据库和非关系型数据库 [面试题解答系列：关系型数据库和非关系型数据的比较](https://blog.csdn.net/AD_plus/article/details/98625795)
2. 存储引擎有哪些 MyISAM 和 InnoDB 区别
- 是否支持行级锁，MyISAM只支持表级锁，InnoDB支持表级锁和行级锁，默认是行级锁
- 是否支持事务和崩溃后的安全恢复，MyISAM不支持事务和崩溃恢复，而InnoDB支持
- 是否支持外键，MyISAM不支持外键，而InnoDB支持
- 是否支持MVCC，MyISAM不支持MVCC，而InnoDB支持
- 一句话总结，不是特别了解存储引擎的话就用InnoDB
3. **MySQL-InnoDB-MVCC多版本并发控制 [MVCC多版本并发控制](https://www.jianshu.com/p/8845ddca3b23)**
- MVCC是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了并发度
- 我们常说的快照读就是用MVCC来实现的
- 原理的话，根据 up_limit_id, low_limit_id, tx_list, tx_current_id 来判断 数据的可见行，有必要的话根据回滚指针在 undo log 中找正确的数据

| 事务1 | 事务2 | 事务3 | 事务4 |
| :--: | :--: | :--: | :--: |
| 事务开始 | 事务开始 | 事务开始 | 事务开始 |
| ... | ... | 修改且提交事务 | ... |
| 快照读 | ... | ... | ... |
| ... | 修改且提交事务 | ... | 修改且提交事务 |

对于以上这个序列，事务1快照读的ReadView是：up_limit_id=2，low_limit_id=5，tr_list包括(2, 4)，tr_current_id=3。3在2、5之间且不在list中，因此可见。

3. **innoDB的RR到底是否解决了幻读？**
- 结论：innodb在快照读的情况下并没有真正的避免幻读, 但是在当前读的情况下避免了不可重复读和幻读!!!
- 原因：
    - 在如果事务B在事务A执行中, insert了一条数据并提交, 事务A再次查询, 虽然读取的是undo中的旧版本数据(防止了部分幻读), 但是事务A中执行update或者delete都是可以成功的!!
    - 在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。
    - MySQL（innodb）的选择是允许在快照读之后执行当前读，并且更新 snapshot 镜像的版本。严格来说，这个结果违反了 repeatable read 隔离级别，，但是 who cares 呢，毕竟官方都说了：“This is not a bug but an intended and documented behavior.”

[MVCC 能解决幻读吗？](https://www.cnblogs.com/twoheads/p/10703023.html)

[看完本文，别再说不知道Mysql怎么解决幻读了](https://zhuanlan.zhihu.com/p/83584160)

[既然MySQL中InnoDB使用MVCC，为什么REPEATABLE-READ不能消除幻读？](https://www.zhihu.com/question/334408495/answer/860085549)

3. 什么是数据库第一类第二类丢失更新？[数据库第一类第二类丢失更新](https://blog.csdn.net/paopaopotter/article/details/79259686)
- 第一类丢失更新，也称“回滚丢失”
- 第二类丢失更新，也称“覆盖丢失”
- 支持事务的数据库都不存在第一类，只会有第二类问题。可以通过“悲观锁 select for update”或“乐观锁 some version number”来解决
4. 字符集及校对规则
- 字符集指的是一种从二进制编码到某类字符符号的映射
- 校对规则则是指某种字符集下的排序规则
5. 索引主要结构，InnoDB B+ 查找过程
- 根据主键查找的话直接在聚簇索引上多路查找，即可取出数据
- 根据非主键查找的话先在非聚簇索引上多路查找，查找到主键ID后去聚簇索引上查找，方可取出数据
6. 查询缓存的使用 配置和sql
- 这个没啥用，而且在8.0已经被废弃了。即使用缓存我也是采用别种方案。
7. **什么是事务? 事物的四大特性(ACID)**
- 逻辑上的一组操作，要么都执行，要么都不执行。
- 原子性：动作要么全部完成，要么完全不起作用
- 一致性：事物执行前后，数据保持一致；多个事物对同一数据读取到的结果是相同的
- 隔离性：并发事务之间是独立的，不被干扰
- 持久性：事务提交后，对数据的改变是持久的
8. **并发事务带来哪些问题?4**
- 脏读：读取到其他事务未提交的数据
- 丢失更改：先query再根据query的值update就可能会出现丢失更新，比如读取到10，想要修改为-5，那么两个线程并发访问，结果应该是0，但是可能结果是5。
- 不可重复读：在一个事务里面，前后两次读取到的数据不一致
- 幻读：在一个事务里面，前后两次读取到的数据条数不一致
9. **事务隔离级别有哪些?MySQL的默认隔离级别是?**
- 读未提交 RU，可能出现脏读、不可重复读、幻读
- 读已提交 RC，解决了脏读，可能出现不可重复读、幻读
- 可重复读 RR，解决了脏读、不可重复读。可能出现幻读
- 串行化 Serializable，可以阻止脏读、不可重复读、换读
10. InnoDB默认隔离级别和sql标准的不同
- InnoDB的RR是由 Next-key Lock 算法实现的，它能达到其他数据库RC的性能，还能部分解决幻读的问题。
11. 锁机制与InnoDB锁算法3种
- Record Lock，记录锁
- Gap Lock，间隙锁
- Next-key Lock，记录锁 + 间隙锁
12. 为什么是部分防止幻读, 而不是完全防止?
- MySQL InnoDB的可重复读并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是next-key locks
12. 大表优化
- 限定数据范围
- 读写分离
- 垂直分表：数据表列的拆分，把一张列比较多的表拆分为多张表；可以简化表结构，减少随机IO次数，但会造成主键冗余，需要Join或应用层Join
- 水平分表：数据库行的拆分，把每一片数据分散到不同的表或者库中，达到了分布式的目的；可以支撑非常大的数据量，但会带来逻辑、部署、运维的各种复杂度
    - 客户端代理：分片逻辑在应用端，如 Sharding-JDBC
    - 中间件代理：在应用和数据层中间加了个代理层，分片逻辑维护在中间件服务中，如 MyCat
13. 解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?
- 池化思想：预设资源，减少每次获取资源的消耗。如 java线程池，jdbc连接池，redis连接池
- 数据库连接本质就是一个 socket 的连接，所以数据库连接池就是socket连接的缓存
- 这个问题和为什么需要线程池是一个道理
    - 降低资源消耗、提高响应速度、方便监控管理
14. 分布式唯一id
- 分布式应用需要一个全局唯一的id，此时就需要分布式id生成算法
- 常见的有 redis Lua Script，雪花算法snowflake，百度的uid-generator，美团的leaf
15. 一条SQL语句在MySQL中如何执行的
- select，权限校验、分析器、优化器、权限校验、执行器、引擎
- update，分析器、权限校验、执行器、引擎、redo log prepare、bin log、redo log commit
16. 一条SQL语句执行得很慢的原因有哪些？
- 突然很慢：刷脏页、获取不到锁
- 一直很慢：没加索引，加了没走（联合索引没满足最左匹配原则，用了装换函数，优化器选错了索引）
17. 为什么优先选择符合存储需要的最小的数据类型
- 字段越小，一个Page里面能容纳的数据关键字就越多，能减少读取磁盘的次数
18. TEXT,BLOB 数据类型的使用
- 尽量不使用，如果要使用，尽量分离到单独的扩展表中
19. 尽可能把所有列定义为 NOT NULL？
- 索引 NULL 列需要额外的空间来保存，所以要占用更多的空间
- 进行比较和计算时要对 NULL 值做特别的处理
20. 限制每张表上的索引数量,建议单张表索引不超过 ？个
- 一般是5个，否则影响插入性能
21. 每个 Innodb 表必须有个主键？
- 是的，因为聚簇索引需要它。如果没有显式定义主键，会创建隐式主键
22. 如何选择索引列的顺序？
- 区分度大的放在左边
- 字段长度小的放在左边
- 使用最频繁的放在左边
23. 覆盖索引？
- 提高性能，不用回表
24. 数据库 SQL 开发规范
- 略
25. 避免数据类型的隐式转换？
- 因为可能无法走索引
26. 双%号  not in 
- 是不走索引的
27. SELECT *  必须使用 SELECT <字段列表>？*
- 避免查询无关的列，无法使用覆盖索引
28. 避免使用子查询，可以把子查询优化为 join 操作 子查询性能差的原因：
- 子查询的结果集无法使用索引（内存临时表还是磁盘临时表都不会存在索引）
29. 避免使用 JOIN 关联太多的表
- 关联的表越多，所占用的内存也就越大，可能造成OOM
- 建议不超过5个
30.  对应同一列进行 or 判断时，使用 in 代替 or
- in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引
31. 禁止使用 order by rand() 进行随机排序
- 不说了，这傻逼行为。推荐在程序中获取随机值，再去数据库取出对应的值
32.  WHERE 从句中禁止对列进行函数转换和计算
- 因为不走索引
33. 在明显不会有重复值时使用 UNION ALL 而不是 UNION
- 避免无意义的去重，消耗CPU和内存资源
34. 拆分复杂的大 SQL 为多个小 SQL
- 拆分后可以并行执行，提高效率
35. 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作
- 避免产生大事务操作
- 可能会造成严重的主从延迟
- binlog 日志为 row 格式时会产生大量的日志
36. 对于大表使用 pt-online-schema-change 修改表结构
- 原理是CopyOnChange
37. 回表的概念
- 根据非聚簇索引叶子节点上的主键id去聚簇索引查找数据
38. 最左前缀原则
- 查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到索引
39. B树和B+树区别
- 非叶子节点只存关键字，然后所有的关键字都在叶子节点出现，叶子节点之间有指针链用于range_query。
40. Hash索引和 B+树索引优劣分析
- 不存在hash碰撞情况下，hash索引时间复杂度O(1)，比B+树快
- Hash索引是无序的，所以只适用于等值查询，而不能用于范围查询；B+树则相反
- 联合索引只能用B+树索引
42. mysql组件5  2层
- Server层
    - 连接器
    - 缓存器
    - 分析器
    - 优化器
    - 执行器
- 引擎层
43. 查询语句和更新语句
- 略
44. binlog  redo log 假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？
- 检测到
45. redis 简介
- key-value的NoSql数据库，高性能，业务场景多
46. 为什么要用 redis 而不用 map/guava 做缓存?
- map 或者 guava 实现的是本地缓存，在多实例情况下，缓存不具有一致性
47. redis 的线程模型
- 事件驱动 + 同步非阻塞IO多路复用
    - 套接字
    - IO多路复用
    - 事件派发器
    - 事件处理器
48. redis 和 memcached 有什么区别？
- redis支持更复杂的数据类型
- redis支持持久化，mem不支持
- redis原生支持集群，mem不支持
- redis使用IO多路复用模型，mem使用多线程+非阻塞IO
49. 为什么 redis 单线程却能支撑高并发？
- IO多路复用的线程模型
- 纯内存操作，而且单线程也减少了上下文切换带来的消耗
50. redis 常见数据结构以及使用场景
- String 保存用户token
- Hash 保存用户信息
- List 保存消息列表
- Set 集合去重，社交系统的共同关注
- Zset 有序集合，直播系统的礼物排行榜
51. redis是怎么对过期key进行删除的？
- 定期删除：每隔100ms随机抽取一些设置了过期时间的key，检查如果过期就删除
- 惰性删除：访问的时候发现key过期了，便删除
52. redis 内存淘汰机制
- volatile-lru
- volatile-ttl
- volatile-random
- allkeys-lru
- allkeys-random
- no-eviction
- volatile-lfu
- allkeys-lfu
53. redis 持久化机制
- RDB(redis database)：创建快照来获得副本
- AOF(append of file)：每一条命令都会写入硬盘中的AOF文件
54. AOF 重写
- 产生一个体积更小的AOF文件，该文件和原文件所保存的数据库状态一致
- 原理是：维护一个缓冲区，用来记录创建文件期间服务器执行的写指令，等到新的AOF文件创建好后，将缓冲区的内容追加到AOF文件末尾
55. redis 事务 假事务
- 通过 multi, exec, watch 等命令实现事务功能。
- redis是单线程，所以很多问题在redis这里都不是问题。
- 另外，严格来讲redis不具有原子性，因为失败后不会回滚，但是作者是这么解释的：redis只会因为错误的语法而失败，是由编程错误造成的，这些错误应该在开发阶段被发现，而不应该出现在生产环境中，因此不需要对回滚进行支持，以保持redis的简单快速
56. 缓存雪崩和缓存穿透问题解决方案
- 缓存雪崩：缓存同一时间大面积的失效，导致请求都落到数据库上，数据库崩掉
    - 缓存高可用，使用本地缓存，限流，尽快恢复数据
- 缓存穿透：大量请求的 key 根本不存在于缓存和数据库中
    - 缓存空对象、Bloom过滤器
- 缓存击穿：请求的 key 不存在于缓存，但存在于数据库中，此时有大量请求去读取这个 key，造成大量请求落到数据库
    - 线程阻塞等待，比如 guava 的 Cache
57. 如何解决 Redis 的并发竞争 Key 问题
- 使用分布式锁，如zk实现的锁
58. 如何保证缓存与数据库双写时的数据一致性?
- Cache aside
- 补偿机制
- Read-Through
- Write-Through
- Write-Behind
- Write-Around
- 参考1: https://bytetech.info/articles/7110509108775616549?from=lark_all_search#doxcnZ0emQKp7HzhEBa6UxAB2De
- 参考2: https://bytetech.info/articles/6972246018461007902?from=lark_all_search
- 读请求：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 写请求：先删除缓存，然后再更新数据库(避免大量地写、却又不经常读的数据导致缓存频繁更新)。
59. RedLock   Redlock为什么不可靠
- 时间回溯会使得Redlock不可靠
    - client1 从 ABC 三个节点处申请到锁，DE由于网络原因请求没有到达
    - C节点的时钟往前推了，导致 lock 过期
    - client2 在CDE处获得了锁，AB由于网络原因请求未到达
    - 此时 client1 和 client2 都获得了锁
60. 单副本，主从，哨兵，集群 redis木桶效应
- 略

61. 数据库的索引有哪几种？为什么要用B+树来做索引？组合索引和几个单个的索引有什么区别？数据库的大表查询优化了解吗？MVCC机制了解不？MVCC机制有什么问题？怎么去解决这个问题？mysql慢语句调优做过吗？说说你是怎么做的？2
- 因为MVCC机制存在第一类丢失更新问题，可以和 next-key lock 一起使用来保证不出现幻读
- 第一类丢失更新(回滚丢失)：A事务撤销时，把已经提交的B事务的更新数据覆盖了
- 第二类丢失更新(覆盖丢失)：A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失

62. redis了解吗？你说说怎么用redis实现分布式锁？讲一下分布式锁，基于zookeeper实现和redis实现在性能上有什么差异？
- 问题一：setnx和expire两个命令分开了，「不是原子操作」
- 问题一：「锁过期释放了，业务还没执行完」
- 问题二：「锁被别的线程误删」。
- Redis分布式锁方案一：SETNX + EXPIRE
- Redis分布式锁方案二：SETNX + value值是(系统时间+过期时间)
- Redis分布式锁方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)
- Redis分布式锁方案四：SET的扩展命令（SET EX PX NX）
- Redis分布式锁方案五：SET EX PX NX  + 校验唯一随机值,再删除
- Redis分布式锁方案六：Redisson框架
- Redis分布式锁方案七：多机实现的分布式锁Redlock+Redisson

https://www.cnblogs.com/wangyingshuo/p/14510524.html?ivk_sa=1024320u

63. todo

数据库事务ACID四大特性
 
 
索引的常见实现方式有哪些，有哪些区别?MySQL的存储引擎有哪些，有哪些区别？InnoDB使用的是什么方式实现索引，怎么实现的？说下聚簇索引和非聚簇索引的区别？
 
 
事务有哪些特性？
 
 
什么是索引覆盖？
 
数据库慢查询优化了解哪些？说了很多，面试官说假如这些都已经做好了还是很慢怎么办？最后不清楚问了下面试官，面试官主要想了解数据库分区的知识。



 
 
redis主从机制了解么？怎么实现的？
 
Redis熟悉么，了解哪些数据结构? zset底层怎么实现的?
 
红黑树了解么，时间复杂度?
既然两个数据结构时间复杂度都是O(logN)，zset为什么不用红黑树
 
 
跳表的查询过程是怎么样的，查询和插入的时间复杂度?
 
CAS了解么？还了解其他同步机制么？


